---
title: "Rapid assessment of Pacific Salmon spawner abundnace to aide with COSEWIC prioritizaiton"
author: "Dylan Glaser"
date: "3/11/2022"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Background
The purpose of this document is to import recent data on pacific salmon spawner abundances, and their designateable and conservation units (i.e. DUs and CUs). We plot abundances and examine trends, define what it means to be data deficient, then explore various metrics to  prioritize populations for reassessment. 
```{r pkgs, warning = FALSE, message = FALSE}
library("tidyverse")
```
### Load and wrangle data
We want to load the most recent data from a [GitHub repo](https://github.com/hertzPSF/COSEWIC-compilation) managed by Eric Hertz at the Pacific Salmon Foundation (PSF). We download the repo, import data we want from it, and tidy it up. 
```{r, warning = FALSE, message = FALSE}
download.file(url = "https://github.com/hertzPSF/COSEWIC-compilation/archive/master.zip",
              destfile = "compilation/hertzPSF-compilation.zip")

unzip(zipfile = "compilation/hertzPSF-compilation.zip", exdir = "compilation")

erics_output <- list.files("compilation/COSEWIC-compilation-main/output")

raw_sp_data <- read.csv(paste0("compilation/COSEWIC-compilation-main/Output/",
                           erics_output[grep("CU_Spawner_Abund", erics_output)]), 
                        header = TRUE) %>%
         mutate(logSp = log(Spawner.Abundance))

cu_metadata <- read.csv(paste0("compilation/COSEWIC-compilation-main/Output/",
                               erics_output[grep("CU_Metadata", erics_output)]), 
                        header = TRUE, na.strings = c("", "NA")) %>%
  filter(!is.na(gen_length)) %>%
  rename(CUID = cuid)

#join, dump pops with NA DUs, and create a du_cu key
sp_data <- left_join(raw_sp_data, select(cu_metadata, CUID, du_number, gen_length), 
                     by = "CUID") %>%
  drop_na(du_number, Spawner.Abundance) %>%
  mutate(du_cu = paste(du_number, CUID)) %>%
  relocate(du_cu, 1) %>%
  arrange(du_cu, Year)
```
#### Get the last 3 generations of spawner abundances
We need to use the metadata to get generation times for each population, then use that to calculate a time span that includes the last 3 generations, as per IUCN guidelines. 

```{r, warning = FALSE, message = FALSE}
last3_gens <- sp_data %>%
  group_by(du_cu) %>%
  mutate(three_gens = gen_length*3) %>%
  filter(Year > (last(Year) - three_gens), Year <= last(Year))
```

```{r, echo = FALSE}
rm(raw_sp_data, erics_output, cu_metadata) #remove some helper objects
```
## Plot spawner abundance
Now we want to plot abundances. We'll make 2 plots for each species and unit: raw spawner abundance and ln-transformed spawner abundance with a linear regression passing through all data points (black) and the last 3 generations (red). **Note that that the axes on figures vary**, some populations have much more monitoring effort and abundance may vary by orders of magnitude.  
This code is cumbersome in order to make it robust, so we've omitted it from the output, but it's worth noting you can choose to save plots or adjust facets.  
**need to make facets all the same size**
```{r}
max_facets <- 20 #how many facets (i.e. panes) per plot?
save_plots <- FALSE
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
for(i in unique(sp_data$Species)){
  sp_data_species <- filter(sp_data, Species == i)
  for(j in unique(sp_data_species$Region)){
    sub_data <- filter(sp_data_species, Region == j) %>%
      complete(Year, Species, Region, du_cu) #explicitly include NA so line draws right
    sub_last3 <- filter(last3_gens, Species == i, Region == j)
    
    if(length(unique(sub_data$du_cu)) > max_facets){
    
      pages <- ceiling(length(unique(sub_data$du_cu))/max_facets)
    
    for(k in 1:pages){
      sub_data_2 <- filter(sub_data, du_cu %in% 
                               unique(sub_data$du_cu)[((k-1)*max_facets)+1:(max_facets*k)])
      
      sub_last3_2 <- filter(sub_last3, du_cu %in% 
                                unique(sub_last3$du_cu)[((k-1)*max_facets)+1:(max_facets*k)])
      
      p <- ggplot(data = sub_data_2, aes(x= Year, y= Spawner.Abundance/1000)) +
        geom_line(color = "grey") +
        geom_point() +
        facet_wrap(~du_cu, scales = "free_y") +
        labs(x= "Year", y = "spawners (thousands)", 
             title = paste0(j, " ", i, " spawner abundance ", "(", k, " of ", pages, ")")) +
        theme_bw() +
        theme(strip.background = element_blank(), axis.text.x = element_text(angle = 45))
      print(p)
      
      p_log <- ggplot(data = sub_data_2, aes(x= Year, y= logSp)) +
        geom_line(color = "grey") +
        geom_point() +
        stat_smooth(method="lm", formula = y~x, color = "black", lty= "dashed", 
                    se = FALSE) +
        stat_smooth(data = sub_last3_2, formula = y~x, method = "lm", color = "red", 
                    se = FALSE, na.rm = TRUE) +
        facet_wrap(~du_cu, scales = "free_y") +
        labs(x= "Year", y = "ln(spawners)", 
             title = paste0("ln ", j, " ", i, " spawner abundance ", 
                            "(", k, " of ", pages, ")")) +
        theme_bw() +
        theme(strip.background = element_blank(), axis.text.x = element_text(angle = 45))
      print(p_log)
      
      if(save_plots){
        ggsave(paste0("output/plots/",j, "_", i, "sp_abundance_", "_", k, ".png"), plot = p)
        ggsave(paste0("output/plots/", j, "_", i, "ln_sp_lm_", "_", k, ".png"), plot = p_log)
      }
    }
  }else{
    p <- ggplot(data = sub_data, aes(x= Year, y= Spawner.Abundance/1000)) +
      geom_line(color = "grey") +
      geom_point() +
      facet_wrap(~du_cu, scales = "free_y") +
      labs(x= "Year", y = "spawners (thousands)", title = paste(j, i, "spawner abundance")) +
      theme_bw() +
      theme(strip.background = element_blank(), axis.text.x = element_text(angle = 45))
    print(p)
    
    p_log <- ggplot(data = sub_data, aes(x= Year, y= logSp)) +
      geom_line(color = "grey") +
      geom_point() +
      stat_smooth(formula = y~x, method="lm", color = "black", lty= "dashed", se = FALSE) +
      stat_smooth(data = sub_last3, formula = y~x, method = "lm", color = "red", 
                  se = FALSE, na.rm = TRUE) +
      facet_wrap(~du_cu, scales = "free_y") +
      labs(x= "Year", y = "ln(spawners)", 
           title = paste(j, i, "ln(spawner abundance)")) +
      theme_bw() +
      theme(strip.background = element_blank(), axis.text.x = element_text(angle = 45))
    print(p_log)
    
    if(save_plots){
      ggsave(paste0("output/plots/", j, "_", i, "_sp_abundance_", ".png"), plot = p)
      ggsave(paste0("output/plots/", j, "_", i, "_ln_sp_lm_", ".png"), plot = p_log)
   }
  }
 }
}
```
```{r, echo=FALSE}
#clean environment for my own sanity
rm(p, p_log, sp_data_species, sub_data, sub_data_2, sub_last3, sub_last3_2)
```
## Linear models of population decline
#### Which populations are data deficient?
Earlier we dropped years where spawner abundance wasn't recorded, but now we want to account for missing data. We'll define a threshold of acceptable data coverage then check the get a list of DUs that don't meet this threshold and filter them out of data that will be used in the lms.  
First we'll do this for the recent data.
```{r, warning = FALSE, message = FALSE}
deficient_recent_perc <- 0.7

deficient_recent <- last3_gens %>%
  group_by(du_cu) %>%
  summarise(n = n(), #years with data  
            n_proper = mean(gen_length)*3) %>% #years for 3 gens of data if fully sampled
  mutate(perc_na = n/n_proper) %>%
  filter(perc_na < deficient_recent_perc) %>%
  pull(du_cu)

last3_gens_filtered <- filter(last3_gens, !(du_cu %in% deficient_recent))
```
Then we'll use similar logic but account for the whole time series using a more forgiving 
cutoff and the first year of sampling. 
```{r, warning = FALSE, message = FALSE}
deficient_historical_perc <- 0.6

deficient_historical <- sp_data %>%
  group_by(du_cu) %>%
  summarise(n = n(),
            n_proper = last(Year) - first(Year) + 1) %>%
  mutate(perc_na = n/n_proper) %>%
  filter(perc_na < deficient_historical_perc) %>%
  pull(du_cu)

sp_data_filtered <- filter(sp_data, !(du_cu %in% deficient_historical))
```
*we could add to this by making it specific to gen_length* (e.g. 3 missing data points from a short lived pop may have more of an impact on our inference than 3 NAs in longer lived pops...)
## Population decline

### Basic linear models 
Now we'll run basic linear models on ln(spawner abundances) for the whole time series and
for the last 3 generations. We need to add some if statements in this loop to account for
which du_cus made it through the data filters above.   
**I'm open to clever suggestions to avoid the if else statements!**
```{r, warning = FALSE, message = FALSE}
summary_table <- NULL

for(i in unique(sp_data_filtered$du_cu)){
  sub_raw <- filter(sp_data, du_cu == i)
  sub_data <- filter(sp_data_filtered, du_cu == i)
  sub_last3 <- filter(last3_gens_filtered, du_cu == i)
  
  if(nrow(sub_data) == 0){
    slope_all <- NA
  } else{
    if(nrow(sub_last3) == 0){
      slope_recent <- NA
    } else{
      model_all <- lm(sub_data$logSp ~ sub_data$Year)
      slope_all <- round(as.numeric((exp(model_all$coefficients[2]*15)-1)*100))

      model_recent <- lm(sub_last3$logSp ~ sub_last3$Year)
      slope_recent <- round(as.numeric((exp(model_recent$coefficients[2]*15)-1)*100))
    }
  }
  recent_abundance <- last(sub_raw$Spawner.Abundance)
  last_year_monitored <- last(sub_raw$Year)
  
  output <- data.frame(du_cu = i, slope_recent, slope_all, recent_abundance, last_year_monitored)
  
  summary_table <- bind_rows(output, summary_table)
}

head(summary_table)
```

```{r, echo = FALSE}
rm(list = ls()[grep("sub|model|def|slope", ls())]) #yeet garbage
```
### Estimates with the MetricsCOSEWIC package
First some housekeeping. You can use devtools to download the [MetricsCOSEWIC package](https://github.com/SOLV-Code/MetricsCOSEWIC) from GitHub. We'll wrangle the data into the format this package wants as well. We'll feed it the filtered last 3 generations.   
*Still need to make sure I did this right. The README says the first argument to calcPercChangeMCMC() is a "vector with numeric values" so I'll assume thats spawner abundance with NAs omitted?*  
**Need to sum the % of draws in each threshold and bind in summary table**
```{r, warning = FALSE, message = FALSE, results = "hide"}
library(MetricsCOSEWIC)

slope_posterior <- NULL
stan_summary <- NULL

for(i in unique(last3_gens_filtered$du_cu)){
  sub_data <- filter(last3_gens_filtered, du_cu == i)
  
  stan_mod <- calcPercChangeMCMC(sub_data$Spawner.Abundance, method = "rstanarm",
                           out.type = "long") #how TF do I shut this up
  
  summary <- data.frame(stan_mod$summary) %>%
    slice(1:3) %>%
    select(mean, se_mean, X2.5., X50., X97.5., n_eff, Rhat) %>%
    rename(perc_2.5 = X2.5., 
           perc_97.5 = X97.5.,
           median = X50.) %>%
    mutate(du_cu = i,
           region = sub_data$Species[1],
           species = sub_data$Region[1]) %>%
    relocate(du_cu, region, species, .before = mean) 
  
  rownames(summary) <- NULL #rownames to columns - probably a better way
  summary$var <- c("intercept", "slope", "sigma")

  stan_summary <- bind_rows(summary, stan_summary)

  slope_posterior <- bind_rows(data.frame(du_cu =i, region = unique(sub_data$Region),
                                          species = unique(sub_data$Species),
                                          draws = stan_mod$samples$slope), slope_posterior)
}

stan_summary <- relocate(stan_summary, var, .before = mean)

```
#### Plot slope posterior distributions
We'll plot the slope (i.e. decline) posteriors and show the median and various COSEWIC thresholds for population decline based on [category A2](https://www.canada.ca/en/environment-climate-change/services/species-risk-act-accord-funding/listing-process/quantitative-criteria-guidelines-status-table-2.html), where 50 and 30 percent reductions correspond to endangered and threatened status, respectively.
**Should I center these on 0 or something?**  
**need to fix ugly plots**
```{r, echo = FALSE, warning = FALSE, message = FALSE}
for(i in unique(slope_posterior$species)){
  post_species <- filter(slope_posterior, species == i)
  for(j in unique(post_species$region)){
    sub_data <- filter(post_species, region == j)
    if(length(unique(sub_data$du_cu)) > max_facets){
      pages <- ceiling(length(unique(sub_data$du_cu))/max_facets)
    for(k in 1:pages){
      sub_data_2 <- filter(sub_data, du_cu %in% 
                               unique(sub_data$du_cu)[((k-1)*max_facets)+1:(max_facets*k)])
      p <- ggplot(data = sub_data, aes(draws)) +
        geom_density(fill = "gray") + 
        #geom_vline(aes(xintercept = median(draws)), color="black") +
        geom_vline(xintercept = -30, color="orange") +
        geom_vline(xintercept = -50, color="red") +
        theme_classic() +
        facet_wrap(~du_cu, scales = "free") +
        labs(title = paste(j, i, "slope posterior", "(", k, " of ", pages, ")"), 
         x = "MCMC draws")
  print(p)
  if(save_plots){
    ggsave(paste0("output/plots/",j, "_", i, "_posterior_", "_", k, ".png"), plot = p)
      }
    }
  }else{
      p <- ggplot(data = sub_data, aes(draws)) +
        geom_density(fill = "gray") + 
        #geom_vline(aes(xintercept = median(draws)), color="black") +
        geom_vline(xintercept = -30, color="orange") +
        geom_vline(xintercept = -50, color="red") +
        theme_classic() +
        facet_wrap(~du_cu, scales = "free") +
        labs(title = paste(j, i, "slope posterior"), x = "MCMC draws")
      print(p)
      if(save_plots){
      ggsave(paste0("output/plots/", j, "_", i, "_posterior_", ".png"), plot = p)
   }
  }
 }
}
```